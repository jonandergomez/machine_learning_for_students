"""
    Author: Jon Ander Gomez Adrian (jon@dsic.upv.es, http://www.dsic.upv.es/~jon)
    Version: 1.0
    Date: November 2015
    Universitat Politecnica de Valencia
    Technical University of Valencia TU.VLC

    Auxiliar code for generating samples
"""

import numpy
#from matplotlib import pyplot


# ---------------------------------------------------------------------------------------------
def generate_multivariate_normals( n_classes=2, dimensionality=2,
                                   n_samples_per_class_training=100,
                                   n_samples_per_class_test=50,
                                   sparsity_between_classes=1.0, sparsity_within_a_class=1.0 ):

    X_train = None
    Y_train = None
    X_test  = None
    Y_test  = None

    for m in range(n_classes):

        # Generate the mean, variances and covariances randomly
        mean = sparsity_between_classes * numpy.random.randn( dimensionality )
        sigma = sparsity_within_a_class * numpy.random.randn( dimensionality, dimensionality )
        # Ensure that sigma is a symmetric matrix
        if dimensionality > 1 :
            for i in range(0,dimensionality):
                sigma[i][i] = abs( sigma[i][i] )
                for j in range(i+1,dimensionality):
                    sigma[i][j] = sigma[j][i];

        sigma = numpy.dot( sigma, sigma ) # For ensuring it is positive semidefinite

        # All the samples generated by the same Gaussian belong to the same class 'm'
        y = numpy.ones( n_samples_per_class_training, dtype=int ) * m
        x = numpy.random.multivariate_normal( mean, sigma, n_samples_per_class_training )

        if X_train is None :
            X_train = x
            Y_train = y
        else:
            X_train = numpy.vstack( [X_train, x] )
            Y_train = numpy.hstack( [Y_train, y] )

        if n_samples_per_class_test > 0:
            y = numpy.ones( n_samples_per_class_test, dtype=int ) * m
            x = numpy.random.multivariate_normal( mean, sigma, n_samples_per_class_test )

            if X_test is None :
                X_test = x
                Y_test = y
            else:
                X_test = numpy.vstack( [X_test, x] )
                Y_test = numpy.hstack( [Y_test, y] )

    return (X_train,Y_train,X_test,Y_test)
# ---------------------------------------------------------------------------------------------


# ---------------------------------------------------------------------------------------------
if __name__ == "__main__" :

    X_train,Y_train,X_test,Y_test = generate_multivariate_normals( 3, 2, 100, 10, 10.0, 2.0 )

    from matplotlib import pyplot
    fig,ax = pyplot.subplots( 1, 1, sharey=False )
    pyplot.scatter( X_train[:,0], X_train[:,1], c=Y_train, s=50, edgecolors='none' )
    pyplot.scatter( X_test[:,0], X_test[:,1], c='red', s=30, edgecolors='none' )
    pyplot.show()
# ---------------------------------------------------------------------------------------------
